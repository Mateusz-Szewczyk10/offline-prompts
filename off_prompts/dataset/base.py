"""Abstract base class functions used in logged dataset."""
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass
from typing import Union, Optional

import torch
from torch import nn

from ..types import Sentence, Tokens


@dataclass
class BaseEncoder(metaclass=ABCMeta):
    """Base class for the encoder.

    Imported as :class:`off_prompts.policy.BaseEncoder`

    Note
    -------
    1. The following parameter should be specified in init.

    dim_emb: int, default=10
        Dimension of embeddings.

    """

    @abstractmethod
    def encode(
        self,
        inputs: Union[Sentence, Tokens],
        context: Optional[torch.Tensor] = None,
        query: Optional[Union[Sentence, Tokens, torch.Tensor]] = None,
        batch_size: int = 128,
    ):
        """Encode input sentence to a low-dimensional vector.

        Parameters
        -------
        inputs: Sentence or Tokens, shape (n_samples, )
            Text inputs, such as sentence, query, and prompt.

        context: torch.Tensor, shape (n_samples, dim_context), default=None
            Context of each user. Required depending on the choice of the encoder model.

        query: Sentence or Tokens or torch.Tensor, shape (n_samples, dim_sentence), default=None
            Query given by users. Required depending on the choice of the encoder model.

        batch_size: int, default=128 (> 0)
            Batch size.

        Return
        -------
        embeddings: torch.Tensor, shape (n_samples, dim_emb)
            Embeddings of the input texts.

        """
        raise NotImplementedError()

    def load(self, path: str):
        """Load PCA matrix to retrieve low-dimensional embeddiings."""
        self.pca_matrix = torch.load(path)

    def save(self, path: str):
        """Save PCA matrix used for retrieving low-dimensional embeddiings."""
        torch.save(self.pca_matrix, path)


@dataclass
class BasePromptFormatter(metaclass=ABCMeta):
    """Base class for formatting prompts.

    Imported as: :class:`off_prompts.dataset.BasePromptFormatter`

    """

    @abstractmethod
    def format_tokens(self):
        """Format tokens."""
        raise NotImplementedError()


@dataclass
class BaseCandidateActionsLoader(metaclass=ABCMeta):
    """Base class for candidate action loader.

    Imported as: :class:`off_prompts.dataset.BaseCandidateActionLoader`

    """


@dataclass
class BaseContextQueryLoader(metaclass=ABCMeta):
    """Base class for context-query loader.

    Imported as: :class:`off_prompts.dataset.BaseContextQueryLoader`

    """

    @abstractmethod
    def sample_context_and_query(
        self,
        n_samples: int,
    ):
        """Sample context and query. Examples of inputs and outputs of this fuction is as follows.

        Parameters
        -------
        n_samples: int
            Number of samples.

        Return
        -------
        user_id: torch.Tensor, shape (n_samples, )
            User id.

        item_id: torch.Tensor, shape (n_samples, )
            Item id.

        context: torch.Tensor, shape (n_samples, )
            Context vector of each user.

        query: Sentence, shape (n_samples, )
            Query sentence given by users.

        """
        raise NotImplementedError()


@dataclass
class BaseFrozenLLM(metaclass=ABCMeta):
    """Base class for frozen LLMs.

    Imported as: :class:`off_prompts.dataset.BaseFrozenLLM`

    """

    @abstractmethod
    def generate_output_sentence(
        self,
        query: Union[Sentence, Tokens],
        prompt: Union[Sentence, Tokens],
    ):
        """Generate sentence using frozen LLM given user-specified query and the prompt chosen by a policy.

        Parameters
        -------
        query: Sentence or Tokens, shape (n_samples, )
            Qurey specified by users.

        prompt: Sentence or Tokens, shape (n_samples, )
            Discrete prompts for each given user context and query.

        Return
        -------
        sentence: Sentence, shape (n_samples, )
            Sentence generated by the frozen LLM.

        """
        raise NotImplementedError()


class BaseRewardSimulator(nn.Module):
    """Base class for reward simulator.

    Imported as: :class:`off_prompts.dataset.BaseRewardSimulator`

    """

    @abstractmethod
    def forward(
        self,
        **kwargs,
    ):
        raise NotImplementedError()

    @abstractmethod
    def calc_expected_reward(
        self,
        **kwargs,
    ):
        """Calculate expected reward. Examples of inputs and outputs of this fuction is as follows.

        Parameters
        -------
        user_id: torch.Tensor, shape (n_sample, )
            User id.

        item_id: torch.Tensor, shape (n_sample, )
            Item id.

        sentence: Sentence or Tokens, shape (n_samples, )
            Sentence generated by frozen LLMs.

        Return
        -------
        expected_reward, shape (n_samples, )
            Expected reward given input variables.

        """
        raise NotImplementedError()
